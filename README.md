# springBackend
엔터프라이즈 애플리케이션 이란?
<br/>
기업과 조직의 업무를 처리해 주는 시스템을 말합니다.
<br/>
많은 사용자의 요청을 동시에 처리해야 하기 때문에 서버의 자원을 효율적으로 공유하고 분배해서 사용할 수 있어야 한다.
<br/>
그런의미에서 자바는 엔터프라이즈 애플리케이션을 개발하는데 하부 구조를 포괄적으로 제공한다.
<br/>
스프링이 하부 구조를 처리하여 애플리케이션 개발에 개발자가 집중할 수 있게 해주며
<br/>
엔터프라이즈 서비스 기능을 POJO에 제공하는 것이다. (쉽게 이야기하면 엔터프라이즈 = 회사, 애플리케이션 = 프로그램 기능이라고 생각하면 된다.)
<br/>
엔터프라이즈 서비스라고 하는 것은 트랜잭션, 보안, 메일, 메시징, 캐시 와 같은 
<br/>
엔터프라이즈 애플리케이션(회사 프로그램에) 요구되는 기술들을 이야기 합니다.
<br/>
<br/>

# 스프링 핵심 기술
<br/>
복잡성을 다루기 위한 스프링의 기본 전략은 비즈니스 로직을 담은 애플리케이션의 코드와
<br/>
엔터프라이즈의 코드를 처리를 분리 시키는 것 입니다.
<br/>
이것을 POJO라고 한다.
<br/>
POJO는 2000년, 마틴 파울러가 컨퍼런스 준비 과정에서 만든 용어이다.
<br/>
객체지향 원리에 충실하며, 특정 규약과 환경에 종속되지 않게 재활용 할수있도록 설계된 방식을 말하며,
<br/>
자동화된 테스트에 유리하며, 유지보수성이 높다.
<br/>
<br/>

# God Object
1개의 파일에 모든 로직을 구현하게 되면 하나의 거대한 클래스가 탄생되며 클래스의 목적을 알수가 없어 진다.
<br/>
또한 유지보수가 쉽지않아 한가지의 변화로 쉽게 망가질 수 있다.
<br/>
이를 God object 안티 패턴이라 명칭한다.
<br/>
<br/>

# 관심사의 분리 (Separation of Concerns)와 계층화 (layering)
<br/>
복잡한 소프트웨어를 계층으로 나눔으로써 서로 영향을 주지 않도록 분리하는 것이다.
<br/>
<br/>

# 도메인 (Domain)
소프트웨어 개발에서 말하는 도메인은 프로그램이 쓰이는 대상 분야라는 의미이다.
<br/>
<br/>

# 소프트웨어 개발시 지켜야 할 두가지 조건
<br/>
오늘 완셩해야 하는 기능을 구현하는 코드를 짜야하는 동시에
<br/>
내일 쉽게 변경할 수 있는 코드를 짜야 한다. - Sandi Metz
<br/>
<br/>

# 추상화
어떤 것들의 공통적인 성격을 뽑아서 이를 따로 분리해내는 작업
<br/>
<br/>

# 템플릿 메서드 패턴 (디자인 패턴에서)
<br/>
부모 클래스의 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 구조
<br/>
<br/>

# 상속은 2가지 관점에서 설계에 안 좋은 영향을 끼친다.
<br/>
1. 캡술화를 위반
<br/>
2. 설계가 유연하지 못함.
<br/>
<br/>

코드를 재사용하기 위해서는 '상속'보다는 '합성'을 사용하는 것이 좋다. (도서:Effective Java 3rd Edittion - Joshua Bloch)
<br/>
*합성: 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법.
<br/>
!추상 클래스보다는 인터페이스를 우선하고 객체는 인터페이스를 사용해 참조하는 것.
<br/>
<br/>

인터페이스를 정의된 객체만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있으며, 참조되는 인스턴스를 교체하는 것이 비교적 쉽다.
<br/>
<br/>

# JAXB(Java Architechture for XML Binding 자바 클래스를 XML로 표현하는 자바 표준 API)의 두 가지 주요 기능
<br/>
마샬링(Marshalling) : 자바 객체 => XML문서
<br/>
언마샬링(Unmarshalling) : XML 문서 => 자바 객체
<br/>
<br/>

# Junit은 자바용 테스트 프레임워크이다.
<br/>
<br/>

# Factory
객체의 생성 방법을 결정하고, 생성한 객체를 반환하는 역할을 수행하는 객체를 보편적으로 Factory라고 부른다.
<br/>
객체를 생성하는 쪽과 생선된 객체를 사용하는 쪽 역할과 책임을 분리하려는 목적으로 사용.
<br/>
<br/>


# 제어의 역전 (제어 권한을 자신이 아닌 다른 대상에게 위임)
일반적인 흐름은 메인 메소드에서 프로그램이 시작되는 지점에서 사용할 객체를 결정하고, 결정한 객체를 생성하고, 생성된 메소드를 호출하며 반복되는것이다.
<br/>
<br/>
*자바프로그램은 메인 메소드를 제외하고 모든 객체는 제어권한을 위임 받은 객체에 의해 결정되고 만들어 진다.
<br/>
<br/>


# SOLID 원칙 (깔끔한 설계를 위해 적용 가능한 5가지 소프트웨어 설계 원칙)
<br/>
함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이 클래스들을 서로 겹합하는 방법으로 구성
<br/>
내부의 구조를 이해하기 쉽고, 변경에 유연하게 만드는데 목적을 두고 있다.

1. 개방 폐쇄 원칙 (Open-Closed Principle; OCP) - 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
<br/>
2. 의존성 역전 원칙 (Dependency-inversion Principle; DIP) - 상위 정책은 하위 정책에 의존하면 안된다. 하위 정책이 상위 정책에 정의된 추상 타입에 의존해야 한다.
<br/>

위 두 원칙은 높은 응집도와 낮은 결합도라는 '관심사의 분리(Separation of Concerns)'와 도 관련이 있다.
<br/>
관심이 같은 것끼리는 한곳으로 모으고, 다른 것은 따로 떨어뜨려 서로 영향을 주지 않도록 분리하는 것이다.
<br/>
응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.
<br/>
결합도가 낮다는 건 하나의 오브젝트가 변경될 때에 관계를 맺고 있는 다른 오브젝트에 영향을 안준다는 뜻이다.
<br/>
<br/>


# 디자인 패턴(Design Pattern)
<br/>
자주 발생하는 문제에 대해 검증된 해결책을 제시한다.
<br/>
<br/>


# 의존 관계 주입 (Dependency Injection) DI
외부에 독립적인 존재가 객체를 생성한 후, 이를 전달해서 의존 관계를 해결하는 방법을 의존 관계 주입이라고 부릅니다.
<br/>
의존 관계 주입에는 3가지 방법이 있다.
<br/>
1.생성자 주입 - 객체를 생성하는 시점에 생성자를 통한 의존 관계 해결.
<br/>
2.설정자 주입 - 객체를 생성한 후, setter 메소드를 통해서 의존 관계를 해결.
<br/>
3.메소드 주입 - 메소드 실행시 인자를 이횽해서 의존 관계를 해결.
<br/>
<br/>

# 다형성
<br/>
객체 지향 프로그램의 코드 시점 의존 관계와 실행 시점 의존 관계가 다를 수 있다는 사실을 기반으로 합니다.
<br/>
서로 다른 메소드를 실행할 수 있게 합니다.
<br/>

객체 지향 설계란 의존관계를 관리하는 것이고 객체가 변경을 받아들일 수 있게 의존 관계를 정리하는 기술이라고 할 수 있다.
<br/>
<br/>


# 스프링 컨테이너 와 Bean 
<br/>
스프링에서는 스프링이 제어권을 가지고 직접 생성하고 의존 관계를 주입하는 객체를 빈이라고 한다. 
<br/>
컨테이너 생성, 관계 설정, 사용들을 제어해주는 제어의 역전 원리가 적용된 객체를 가리키는 말이다.
<br/>

* 스프링은 IoC 컨테이너인 애플리케이션 콘텍스트나 빈 팩토리로 빈 구성 정보를 읽어 애플리케이션을 구성합니다.
<br/>
<br/>

# 스프링 IoC컨테이너 (Spring IoC Container)와 빈(Beans)
<br/>
컨테이너는 제어의 역전 원리가 적용된 스프링 핵심 컴포넌트다.
<br/>
컨테이너에 의해 생성 및 조립된 후 관리(초기화, 소명 등)되는 객체를 빈(Beans)이라 부른다.
<br/>
빈 생성 시 의존관계 주입(Dependency Injection, DI)이 일어난다.
<br/>
빈 구성정보를 바탕으로 비즈니스 오브젝트를 이용해 애플리케이션 구성하고 생애를 관리한다.
<br/>
<br/>

*스프링 IoC 컨테이너의 가장 기초적인 역할은 스프링은 빈 구성 정보를 읽고, 내부적으로 추상화된 객체를 반들어 사용하는 것이다.
<br/>
스프링은 빈 구성정보를 읽고 내부적으로 Bean Definition이라는 인터페이스로 추상화된 객체를 만들어 사용합니다.
<br/>
! 빈 구성정보는 특정한 파일 포맷이나 형식에 제한되거나 종속되지 않습니다.
<br/>
<br/>

# 빈 구성정보(Configuration Metadata)란?
<br/>
스프링 컨테이너가 빈 객체가 생성 및 구성, 조립시 사용하는 설정정보다.
<br/>
컨테이너 기능을 설정하거나 조정이 필요할 때도 사용된다.
<br/>
자바, 코틀린, 그루비(Groovy), XML등 다양한 방식으로 작성할 수 있다. 
<br/>
<br/>

! 스프링 3.1 이하로 작성된 스프링 애플리케이션은 주로 XML형식으로 빈 구성 정보를 작성했으나, 최근에는 자바 코드로 빈 구성 정보를 작성하는 경우가 훨씬 많다.
<br/>
스프링 부트를 사용하게 되면 특별한 경우가 아니고서는 자바 코드로 빈 구성 정보를 작성하는 것을 권하고 있다.
<br/>
<br/>


*애노테이션은 자바5 버전에 등장했고, 자바 코드의 메타 데이터로 컴파일 또는 런타임에 활용된다.
<br/>
자바가 제공하는 빌트인 애노테이션과 개발자가 직접 작성할 수 있는 커스텀 애노테이션으로 분류가 되어 있다.
<br/>
<br/>

빌트인 애노테이션 - @Override / @Deprecated 
<br/>
커스텀 애노테이션 - @Configuration / @Bean
<br/>
<br/>

자바 기반의 컨테이너 구성의 핵심은 @Configuration / @Bean이 달려 있는 클래스이다.
<br/>
또한 이 두 애노테이션으로 구성할 수 있는 AnnotationConfigApplicationContext 클래스이다.
<br/>
<br/>

예시 -
<br/>
```Java
@Configuration	
public class MovieBuddyFactory {
	
	@Bean
	public MovieFinder movieFinder() {
		return new MovieFinder(new CsvMovieReader());
	}
```
	
! 클래스 레벨에  Configuration을 선언하면 그 클래스는 컨테이너의 빈 구성 정보로 사용하려는 목적이다.
그리고 매서드 레벨에 빈을 선언하면, 그 메서드는 컨테이너에 등록하고 관리할 빈 객체를 생성하고 구성 및 초기화하는 것을 나타낸다고 보면 된다.
<br/>
<br/>
  
  
```Java	
<beans>
	<bean id="MovieFinder" class="com.movies.MovieFinder">
</beans>
```

<br/>
<br/>

이렇게 xml로 작성된 내용과 자바 코드로 작성된 내용은 결국 동일하게 스프링에 빈을 등록해 주기 위한 빈 구성 정보로 활용될 수 있다.
<br/>


 # 스프링의 빈 스코프
 <br/>
 스프링 컨테이너는 빈을 생성할때 단 하나의 빈을 만들지, 아니면 빈이 요철될 때마다 새로운 빈 객체를 생성할지 결정하는 메커니즘을 가지고 있습니다.
 <br/>
 이 메커니즘을 '빈 스코프'라고 한다.
 <br/>
 <br/>
 
 단 하나의 빈 객체만 만들 때에는 싱글톤 스코프라고 부르며, 빈이 요청될 때마다 새로운 빈을 생성하는 것을 프로토타입 스코프라고 부른다.
 <br/>
 *빈을 설정할때 별도로 설정해 주지 않으면, 기본적으로 싱글톤 스코프가 지정된다.
 <br/>
 
 # 싱글톤 스코프
 <br/>
 모든 빈의 기본 스코프로, 스프링 컨테이너가 시작될때 생성되고, 스프링 컨테이너가 종료될 때 소멸됩니다.
 <br/>
 싱글톤 스코프 빈은 스프링 컨테이너 내에서 단 하나만 생성되고, 그 빈을 의존하는 모든 빈에 유일한 객체를 공유합니다.
 <br/>
 <br/>
 
 # 프로토타입 스코프
 <br/>
 스프링 컨테이너가 빈을 요청받을 때마다 항상 새로운 빈을 생성해서 반환하도록 동작한다.
 <br/>
 <br/>
 
